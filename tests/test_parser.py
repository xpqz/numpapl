import pytest 

from apl import APL

def parse_only(src):
    p = APL(parse_only=True)
    ast = p.parse(src)

    if ast is None:
        return None

    return str(ast)

test_data = [
    ("1 +⍨ 2", "((0, ((1, ('+', '⍨')), 2)),)"),
    ("a (+⍤1 0) b", "(-1, -1, -1, (2, 'a'), ((1, ('(', ('+', ('⍤', (1, 0))))), ((2, 'b'), (-1, -1))))"),
    ("var←99", "((0, (('var', '←'), 99)),)"),
    ("v←⍳99 ⋄ s←+⌿v", "(-1, -1, -1, (15, ((('v', '←'), ('⍳', 99)), '⋄')), ((1, (('s', '←'), ('+', '⌿'))), ((2, 'v'), (-1, -1))))"),
    ("⎕IO←0", "((0, (('⎕IO', '←'), 0)),)"),
    ("1 2 3 ⌊⍥≢ 1 2 3 4", "((0, ((((1, 2), 3), ('⌊', ('⍥', '≢'))), (((1, 2), 3), 4))),)"),
    ("a ← -b ← 3", "((0, (('a', '←'), ('-', (('b', '←'), 3)))),)"),
    ("{⍺+⍵}", "((1, ('{', (('⍺', '+'), '⍵'))),)"),
    ("Add←{⍺+⍵}", "((1, (('Add', '←'), ('{', (('⍺', '+'), '⍵')))),)"),
    ("a←3 {⍺+⍵} 1 2 3 4", "((0, (('a', '←'), ((3, ('{', (('⍺', '+'), '⍵'))), (((1, 2), 3), 4)))),)"),
    ("1 {⍺+⍵} 2", "((0, ((1, ('{', (('⍺', '+'), '⍵'))), 2)),)"),
    ("1 A 2", "(-1, -1, -1, (0, 1), ((2, 'A'), ((0, 2), (-1, -1))))"),
    ("1 a 2", "(-1, -1, -1, (0, 1), ((2, 'a'), ((0, 2), (-1, -1))))"),
    ("{⍺+⍵}/⍳8", "((0, ((('{', (('⍺', '+'), '⍵')), '/'), ('⍳', 8))),)"),
    ("Add←{⍺+⍵}⋄Add⌿⍳8", "(-1, -1, -1, (15, ((('Add', '←'), ('{', (('⍺', '+'), '⍵'))), '⋄')), ((2, 'Add'), ((3, '⌿'), ((0, ('⍳', 8)), (-1, -1)))))"),
    ("2 3⍴⍬", "((0, (((2, 3), '⍴'), '⍬')),)"),
    ("a[2]←5", "((0, (('a', (('[', 2), '←')), 5)),)"),
    ("a[2 2 3]←5 8 7", "((0, (('a', (('[', ((2, 2), 3)), '←')), ((5, 8), 7))),)"),
    ("a[2 3]", "((2, ('a', ('[', (2, 3)))),)"),
    ("1 2 3 4[2]", "((0, ((((1, 2), 3), 4), ('[', 2))),)"),
    ("(1 2 3 4)[2]", "((0, (('(', (((1, 2), 3), 4)), ('[', 2))),)"),
    ("a[1] b[2] c[3]", "((2, (('a', ('[', 1)), (('b', ('[', 2)), ('c', ('[', 3))))),)"),
    ("(a[1] b[2] c)[1]", "((2, (('(', (('a', ('[', 1)), (('b', ('[', 2)), 'c'))), ('[', 1))),)"),
    ("a←2 2⍴1 2 3 4⋄a[(1 0)(0 0)]", "(-1, -1, -1, (15, ((('a', '←'), (((2, 2), '⍴'), (((1, 2), 3), 4))), '⋄')), ((2, ('a', ('[', (('(', (1, 0)), ('(', (0, 0)))))), (-1, (-1, -1))))"),
    ("'c'", "((0, array(['c'], dtype='<U1')),)"),
    ("a←'hello world'", "((0, (('a', '←'), array(['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd'], dtype='<U1'))),)"),
    ("'abcd'~'bde'", "((0, ((array(['a', 'b', 'c', 'd'], dtype='<U1'), '~'), array(['b', 'd', 'e'], dtype='<U1'))),)"),
    ("''", "((0, array([], dtype='<U1')),)"),
    ("1 - 2 - 3 - 4", "((0, ((1, '-'), ((2, '-'), ((3, '-'), 4)))),)"),
    ("(1 2 3)(4 5 6)", "((0, (('(', ((1, 2), 3)), ('(', ((4, 5), 6)))),)"),
    ("(1 2 3)4", "((0, (('(', ((1, 2), 3)), 4)),)"),
]

@pytest.mark.parametrize("test_input,expected", test_data)
def test_eval(test_input, expected):
    assert parse_only(test_input) == expected

diamond_data = [
    ("1⋄2", "((0, ((1, '⋄'), 2)),)"),
    ("x←1⋄2+3", "((0, (((('x', '←'), 1), '⋄'), ((2, '+'), 3))),)"),

    # NOTE: this is a parse failure, but it's failing like the the 
    # dfns version does :/
    # ┌──┬──┬──┬───────────────┬────────────────────┐
    # │¯1│¯1│¯1│┌──┬──────────┐│┌───┬──────────────┐│
    # │  │  │  ││15│┌──────┬─┐│││2 x│┌──────┬─────┐││
    # │  │  │  ││  ││┌──┬─┐│⋄││││   ││┌─┬──┐│¯1 ¯1│││
    # │  │  │  ││  │││x←│1││ ││││   │││0│+3││     │││
    # │  │  │  ││  ││└──┴─┘│ ││││   ││└─┴──┘│     │││
    # │  │  │  ││  │└──────┴─┘│││   │└──────┴─────┘││
    # │  │  │  │└──┴──────────┘│└───┴──────────────┘│
    # └──┴──┴──┴───────────────┴────────────────────┘
    ("x←1⋄x+3", "(-1, -1, -1, (15, ((('x', '←'), 1), '⋄')), ((2, 'x'), ((0, ('+', 3)), (-1, -1))))"), 
]

@pytest.mark.parametrize("test_input,expected", diamond_data)
def test_diamond(test_input, expected):
    assert parse_only(test_input) == expected

dfns_data = [
    # ('1+2-3×4÷5', "((0, ((1, '+'), ((2, '-'), ((3, '×'), ((4, '÷'), 5))))),)"), # dyadic functions and arrays
    # ('1+-×÷5', "((0, ((1, '+'), ('-', ('×', ('÷', 5))))),)"), # monadic functions
    # ('+∘×¨2+3', "((0, ((('+', ('∘', '×')), '¨'), ((2, '+'), 3))),)"), # operator-function binding
    # ('+∘-∘×∘÷', "((1, ((('+', ('∘', '-')), ('∘', '×')), ('∘', '÷'))),)"), # operator-operand sequences associate left.
    # ('+∘2 3', "((1, ('+', ('∘', (2, 3)))),)"), # strand binds tighter than dop
    # ('(2+3)×4', "((0, ((('(', ((2, '+'), 3)), '×'), 4)),)"), # parentheses in array-function sequence.
    # ('+∘(×∘÷)', "((1, ('+', ('∘', ('(', ('×', ('∘', '÷')))))),)"), # parentheses in function-operator sequence.
    # ('(+∘×)∘÷', "((1, (('(', ('+', ('∘', '×'))), ('∘', '÷'))),)"), # redundant parentheses.
    # ('(1 2)3+4(5 6)', "((0, (((('(', (1, 2)), 3), '+'), (4, ('(', (5, 6))))),)"), # array stranding
    # ('1 2 3', "((0, ((1, 2), 3)),)"),
    # ('(1 2)3', "((0, (('(', (1, 2)), 3)),)"),
    # ('1(2 3)', "((0, (1, ('(', (2, 3)))),)"), # stranding distinctions.
    # ('+∘÷', "((1, ('+', ('∘', '÷'))),)"), # jots 'n dots
    # ('#.×.∘.+.×∘÷', "((1, ((((('#', '.'), '×'), ('.', ('∘', ('.', '+')))), ('.', '×')), ('∘', '÷'))),)"), # jot 'n dot medley
    # ('(1+)∘(1+)', "((1, (('(', (1, '+')), ('∘', ('(', (1, '+'))))),)"), # monadic function (MF) as operand.
    # ('(1+)⍣2', "((1, (('(', (1, '+')), ('⍣', 2))),)"), # monadic function (MF) as operand.
    # ('1+¨', "((4, (1, ('+', '¨'))),)"), # test binding difference
    # ('(1+)¨', "((1, (('(', (1, '+')), '¨')),)"), # test binding difference
    # ('⍣∘', "((8, ('⍣', '∘')),)"), # jot-as-null: power limit.
    # ('↑⍣∘', "((1, ('↑', ('⍣', '∘'))),)"), # disclose limit.
    # ('∘.+', "((1, ('∘', ('.', '+'))),)"), # outer product vs. compose
    # ('+∘1', "((1, ('+', ('∘', 1))),)"), # outer product vs. compose

    # ('# #.a[1]', ""), # FIXME: FAIL: strand vs dot vs index. 

    # ('x←2 3', "((0, (('x', '←'), (2, 3))),)"), # array naming.
    # ('y←+.×', "((1, (('y', '←'), ('+', ('.', '×')))),)"), # function naming.
    # ('z←¨', "((8, (('z', '←'), '¨')),)"), # mop naming.
    # ('z←⍣', "((9, (('z', '←'), '⍣')),)"), # dop naming.
    # ('z←∘', "((5, (('z', '←'), '∘')),)"), # jot 'n dot naming.
    # ('z←.', "((9, (('z', '←'), '.')),)"), # jot 'n dot naming.
    # ('+(z←∘)÷', "((1, ('+', (('(', (('z', '←'), '∘')), '÷'))),)"), # naming null/compose.
    # ('(z←∘).×', "((1, (('(', (('z', '←'), '∘')), ('.', '×'))),)"), # naming null/compose.
    # ('(x←∘).((y←∘)(z←.)(x←∘))', "((1, (('(', (('x', '←'), '∘')), ('.', ('(', (('(', (('y', '←'), '∘')), (('(', (('z', '←'), '.')), ('(', (('x', '←'), '∘')))))))),)"), # jot 'n dot naming.
    # ('x y', "((2, ('x', 'y')),)"), # name stranding.
    # ('(x y)←3 4', "((0, ((('(', ('x', 'y')), '←'), (3, 4))),)"), # struct naming.
    # ('(x(y z))←(1 2)3', "((0, ((('(', ('x', ('(', ('y', 'z')))), '←'), (('(', (1, 2)), 3))),)"), # struct naming.

    # ('a x←3', ""), # FIXME: FAIL: stranding with naming.

    # ('(x←+)(y←/)(z←3)', "((0, ((('(', (('x', '←'), '+')), ('(', (('y', '←'), '/'))), ('(', (('z', '←'), 3)))),)"), # naming en-passant.
    # ('x←1:2⋄3', "((0, (((((('x', '←'), 1), ':'), 2), '⋄'), 3)),)"), # naming guard condition
    # ('x←(1:2⋄3)', "((0, (('x', '←'), ('(', ((((1, ':'), 2), '⋄'), 3)))),)"), # naming guard expression
    # ('1(z←/)¨2', "((0, ((1, (('(', (('z', '←'), '/')), '¨')), 2)),)"), # naming retains hybrid behaviour
    # ('+(z←/)¨2', "((0, ((('+', ('(', (('z', '←'), '/'))), '¨'), 2)),)"), # naming retains hybrid behaviour
    # ('+/¨0', "((0, ((('+', '/'), '¨'), 0)),)"), # hybrids: defining example.
    # ('1/¨0', "((0, ((1, ('/', '¨')), 0)),)"), # hybrids: defining example.
    # ('/./', "((1, ('/', ('.', '/'))),)"), # hybrids, jots 'n dots
    # ('/∘/', "((1, ('/', ('∘', '/'))),)"), # hybrids, jots 'n dots
    # ('x←↑(//)(1 2)(3 4)', "((0, (('x', '←'), ('↑', (('(', ('/', '/')), (('(', (1, 2)), ('(', (3, 4))))))),)"), # replication-reduction
    # ('z←//', "((1, (('z', '←'), ('/', '/'))),)"), # ← doesn't bind with /
    # ('⍺=0: ⍵+1', "((0, (((('⍺', '='), 0), ':'), (('⍵', '+'), 1))),)"), # guard.
    # ('0 ⋄ 1 ⋄ 2 ⋄ 3', "((0, ((((((0, '⋄'), 1), '⋄'), 2), '⋄'), 3)),)"), # diamond segments.
    # ('0:0+0 ⋄ 0:1+1 ⋄ 0:2+2 ⋄ 3', "((0, ((((((((0, ':'), ((0, '+'), 0)), '⋄'), ((0, ':'), ((1, '+'), 1))), '⋄'), ((0, ':'), ((2, '+'), 2))), '⋄'), 3)),)"), # guarded segments.
    # ('(z←+ ⋄ 1+2)+3', "((0, ((('(', (((('z', '←'), '+'), '⋄'), ((1, '+'), 2))), '+'), 3)),)"), # leading non-array segment.
    # (' ⋄ ⋄ ', "((15, ('⋄', '⋄')),)"), # expression lists
    # (' ⋄ ⋄2', "((0, (('⋄', '⋄'), 2)),)"), # expression lists
    # (' ⋄1⋄ ', "((15, (('⋄', 1), '⋄')),)"), # expression lists
    # (' ⋄1⋄2', "((0, ((('⋄', 1), '⋄'), 2)),)"), # expression lists
    # ('0⋄ ⋄ ', "((15, ((0, '⋄'), '⋄')),)"), # expression lists
    # ('0⋄ ⋄2', ((0, (((0, '⋄'), '⋄'), 2)),)"), # expression lists
    # ('0⋄1⋄ ', "((15, (((0, '⋄'), 1), '⋄')),)"), # expression lists
    # ('0⋄1⋄2', "((0, ((((0, '⋄'), 1), '⋄'), 2)),)"), # expression lists
    # ('0⋄0', "((0, ((0, '⋄'), 0)),)"), # expression lists
    # ('+⋄0', "((0, (('+', '⋄'), 0)),)"), # expression lists
    # ('/⋄0', "((0, (('/', '⋄'), 0)),)"), # expression lists
    # ('¨⋄0', "((0, (('¨', '⋄'), 0)),)"), # expression lists
    # ('⍣⋄0', "((0, (('⍣', '⋄'), 0)),)"), # expression lists
    # ('∘⋄0', "((0, (('∘', '⋄'), 0)),)"), # expression lists
    # ('.⋄0', "((0, (('.', '⋄'), 0)),)"), # expression lists

    # ('[ ;;]', "((10, ('[', (';', ';'))),)"), # subscripts
    # ('[ ;;3]', "((10, ('[', ((';', ';'), 3))),)"), # subscripts
    # ('[ ;2;]', "((10, ('[', ((';', 2), ';'))),)"), # subscripts
    # ('[ ;2;3]', "((10, ('[', (((';', 2), ';'), 3))),)"), # subscripts

    ('()', ""), # empty brackets FIXME: FAIL: 
    # ('[]', ""), # empty brackets FIXME: FAIL:
    # ('{}', ""), # empty brackets FIXME: FAIL:

    # ('⍵[;;]', "((0, ('⍵', ('[', (';', ';')))),)"), # decreasing rank
    # ('⍵[;]', "((0, ('⍵', ('[', ';'))),)"), # decreasing rank
    # ('⍵[]', ""), # decreasing rank FIXME: FAIL: 

    # ('a[1][2][3]', "((2, ((('a', ('[', 1)), ('[', 2)), ('[', 3))),)"), # contiguous IDXs.
    # ('x[2]←0', "((0, (('x', (('[', 2), '←')), 0)),)"), # indexed assignment
    # ('[0]←', "((11, (('[', 0), '←')),)"), # partial indexed assignment

    # ('a x[2]←0', ""), # stranding with indexed assignment. FIXME: FAIL
    # ('(x y)[0]←1', ""), # selective assignment.
    # ('1/[0]⍵', ""), # hybrid-fn axis
    # ('+/[0]⍵', ""), # derived-fn axis
    # ('2+/[0]⍵', ""), # dyadic derived-fn axis
    # ('(1/)[0]⍵', ""), # AF with axis
    # ('⍵[1]', ""), # array, function, name
    # ('+[1]', ""), # array, function, name
    # ('z[1]', ""), # array, function, name
    # ('{+/[0]⍵}(2 3⍴⍳4)[;0]', ""), # parentheses, brackets and braces.
    # ('+-×÷', ""), # function train.
    # ('1+÷', ""), # Agh train
    # ('÷1+', ""), # fBh train
    # ('1+3×', ""), # A(fBh)
    # ('1+2-3×4÷', ""), # longer (A:F)* train
    # ('+/÷⍴', ""), # train for vector mean
    # ('/∘⊢', ""), # fix / as replicate function
    # ('+/×', ""), # 2-train
    # ('+(/∘⊢)×', ""), # 3-train
    # ('∘', ""), # single token.
    # ('()', ""), # null expression: error.
    # ('(((3)))', ""), # deep parentheses.
    # ('#.a #.(b+1) #.#.c + 2', ""), # lotsa dots.
    # ('{⍵=1:1 ⋄ 2|⍵:∇ 1+3×⍵ ⋄ ∇ ⍵÷2}', ""), # →osc← function
    # ('x←3 4⍴⍳5 ⋄ #.a ∘.+ b[⍳3;] +.× ∘.{(+/⍵)÷⍴⍵}⍨ c', ""), # complex expression
]

@pytest.mark.parametrize("test_input,expected", dfns_data)
def test_dfns(test_input, expected):
    assert parse_only(test_input) == expected
