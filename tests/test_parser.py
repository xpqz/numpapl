import pytest 

from aplparser import APL

def parse_only(src):
    p = APL()
    tokens = p.tokenise(src)
    ast = p.parse(tokens)

    if ast is None:
        return None

    return str(ast)

test_data = [
    ("1 +⍨ 2", "((0, ((1, ('+', '⍨')), 2)),)"),
    ("a (+⍤1 0) b", "((0, (('a', ('(', ('+', ('⍤', (1, 0))))), 'b')),)"),
    ("var←99", "((0, (('var', '←'), 99)),)"),
    ("v←⍳99 ⋄ s←+⌿v", "((0, (((('v', '←'), ('⍳', 99)), '⋄'), (('s', '←'), (('+', '⌿'), 'v')))),)"),
    ("⎕IO←0", "((0, (('⎕IO', '←'), 0)),)"),
    ("1 2 3 ⌊⍥≢ 1 2 3 4", "((0, ((((1, 2), 3), ('⌊', ('⍥', '≢'))), (((1, 2), 3), 4))),)"),
    ("a ← -b ← 3", "((0, (('a', '←'), ('-', (('b', '←'), 3)))),)"),
    ("{⍺+⍵}", "((1, ('{', (('⍺', '+'), '⍵'))),)"),
    ("Add←{⍺+⍵}", "((1, (('Add', '←'), ('{', (('⍺', '+'), '⍵')))),)"),
    ("a←3 {⍺+⍵} 1 2 3 4", "((0, (('a', '←'), ((3, ('{', (('⍺', '+'), '⍵'))), (((1, 2), 3), 4)))),)"),
    ("1 {⍺+⍵} 2", "((0, ((1, ('{', (('⍺', '+'), '⍵'))), 2)),)"),
    ("1 A 2", "((0, ((1, 'A'), 2)),)"),
    ("1 a 2", "((0, ((1, 'a'), 2)),)"),
    ("{⍺+⍵}/⍳8", "((0, ((('{', (('⍺', '+'), '⍵')), '/'), ('⍳', 8))),)"),
    ("Add←{⍺+⍵}⋄Add⌿⍳8", "((0, (((('Add', '←'), ('{', (('⍺', '+'), '⍵'))), '⋄'), (('Add', '⌿'), ('⍳', 8)))),)"),
    ("2 3⍴⍬", "((0, (((2, 3), '⍴'), '⍬')),)"),
    ("a[2]←5", "((0, (('a', (('[', 2), '←')), 5)),)"),
    ("a[2 2 3]←5 8 7", "((0, (('a', (('[', ((2, 2), 3)), '←')), ((5, 8), 7))),)"),
    ("a[2 3]", "((0, ('a', ('[', (2, 3)))),)"),
    ("1 2 3 4[2]", "((0, ((((1, 2), 3), 4), ('[', 2))),)"),
    ("(1 2 3 4)[2]", "((0, (('(', (((1, 2), 3), 4)), ('[', 2))),)"),
    ("a[1] b[2] c[3]", "((0, (('a', ('[', 1)), (('b', ('[', 2)), ('c', ('[', 3))))),)"),
    ("(a[1] b[2] c)[1]", "((0, (('(', (('a', ('[', 1)), (('b', ('[', 2)), 'c'))), ('[', 1))),)"),
    ("a←2 2⍴1 2 3 4⋄a[(1 0)(0 0)]", "((0, (((('a', '←'), (((2, 2), '⍴'), (((1, 2), 3), 4))), '⋄'), ('a', ('[', (('(', (1, 0)), ('(', (0, 0))))))),)"),
    ("'c'", "((0, array(['c'], dtype='<U1')),)"),
    ("a←'hello world'", "((0, (('a', '←'), array(['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd'], dtype='<U1'))),)"),
    ("'abcd'~'bde'", "((0, ((array(['a', 'b', 'c', 'd'], dtype='<U1'), '~'), array(['b', 'd', 'e'], dtype='<U1'))),)"),
    ("''", "((0, array([], dtype='<U1')),)"),
    ("1 - 2 - 3 - 4", "((0, ((1, '-'), ((2, '-'), ((3, '-'), 4)))),)"),
    ("(1 2 3)(4 5 6)", "((0, (('(', ((1, 2), 3)), ('(', ((4, 5), 6)))),)"),
    ("(1 2 3)4", "((0, (('(', ((1, 2), 3)), 4)),)"),
    ("1⋄2", "((0, ((1, '⋄'), 2)),)"),
    ("x←1⋄2+3", "((0, (((('x', '←'), 1), '⋄'), ((2, '+'), 3))),)"),
    ("x←1⋄x+3", "((0, (((('x', '←'), 1), '⋄'), (('x', '+'), 3))),)"), 
    ('1+2-3×4÷5', "((0, ((1, '+'), ((2, '-'), ((3, '×'), ((4, '÷'), 5))))),)"), # dyadic functions and arrays
    ('1+-×÷5', "((0, ((1, '+'), ('-', ('×', ('÷', 5))))),)"), # monadic functions
    ('+∘×¨2+3', "((0, ((('+', ('∘', '×')), '¨'), ((2, '+'), 3))),)"), # operator-function binding
    ('+∘-∘×∘÷', "((1, ((('+', ('∘', '-')), ('∘', '×')), ('∘', '÷'))),)"), # operator-operand sequences associate left.
    ('+∘2 3', "((1, ('+', ('∘', (2, 3)))),)"), # strand binds tighter than dop
    ('(2+3)×4', "((0, ((('(', ((2, '+'), 3)), '×'), 4)),)"), # parentheses in array-function sequence.
    ('+∘(×∘÷)', "((1, ('+', ('∘', ('(', ('×', ('∘', '÷')))))),)"), # parentheses in function-operator sequence.
    ('(+∘×)∘÷', "((1, (('(', ('+', ('∘', '×'))), ('∘', '÷'))),)"), # redundant parentheses.
    ('(1 2)3+4(5 6)', "((0, (((('(', (1, 2)), 3), '+'), (4, ('(', (5, 6))))),)"), # array stranding
    ('1 2 3', "((0, ((1, 2), 3)),)"),
    ('(1 2)3', "((0, (('(', (1, 2)), 3)),)"),
    ('1(2 3)', "((0, (1, ('(', (2, 3)))),)"), # stranding distinctions.
    ('+∘÷', "((1, ('+', ('∘', '÷'))),)"), # jots 'n dots
    ('#.×.∘.+.×∘÷', "((1, ((((('#', '.'), '×'), ('.', ('∘', ('.', '+')))), ('.', '×')), ('∘', '÷'))),)"), # jot 'n dot medley
    ('(1+)∘(1+)', "((1, (('(', (1, '+')), ('∘', ('(', (1, '+'))))),)"), # monadic function (MF) as operand.
    ('(1+)⍣2', "((1, (('(', (1, '+')), ('⍣', 2))),)"), # monadic function (MF) as operand.
    ('1+¨', "((4, (1, ('+', '¨'))),)"), # test binding difference
    ('(1+)¨', "((1, (('(', (1, '+')), '¨')),)"), # test binding difference
    ('⍣∘', "((8, ('⍣', '∘')),)"), # jot-as-null: power limit.
    ('↑⍣∘', "((1, ('↑', ('⍣', '∘'))),)"), # disclose limit.
    ('∘.+', "((1, ('∘', ('.', '+'))),)"), # outer product vs. compose
    ('+∘1', "((1, ('+', ('∘', 1))),)"), # outer product vs. compose
    ('x←2 3', "((0, (('x', '←'), (2, 3))),)"), # array naming.
    ('y←+.×', "((1, (('y', '←'), ('+', ('.', '×')))),)"), # function naming.
    ('z←¨', "((8, (('z', '←'), '¨')),)"), # mop naming.
    ('z←⍣', "((9, (('z', '←'), '⍣')),)"), # dop naming.
    ('z←∘', "((5, (('z', '←'), '∘')),)"), # jot 'n dot naming.
    ('z←.', "((9, (('z', '←'), '.')),)"), # jot 'n dot naming.
    ('+(z←∘)÷', "((1, ('+', (('(', (('z', '←'), '∘')), '÷'))),)"), # naming null/compose.
    ('(z←∘).×', "((1, (('(', (('z', '←'), '∘')), ('.', '×'))),)"), # naming null/compose.
    ('(x←∘).((y←∘)(z←.)(x←∘))', "((1, (('(', (('x', '←'), '∘')), ('.', ('(', (('(', (('y', '←'), '∘')), (('(', (('z', '←'), '.')), ('(', (('x', '←'), '∘')))))))),)"), # jot 'n dot naming.
    ('x y', "((0, ('x', 'y')),)"), # name stranding.
    ('(x y)←3 4', "((0, ((('(', ('x', 'y')), '←'), (3, 4))),)"), # struct naming.
    ('(x(y z))←(1 2)3', "((0, ((('(', ('x', ('(', ('y', 'z')))), '←'), (('(', (1, 2)), 3))),)"), # struct naming.
    ('(x←+)(y←/)(z←3)', "((0, ((('(', (('x', '←'), '+')), ('(', (('y', '←'), '/'))), ('(', (('z', '←'), 3)))),)"), # naming en-passant.
    ('x←1:2⋄3', "((0, (((((('x', '←'), 1), ':'), 2), '⋄'), 3)),)"), # naming guard condition
    ('x←(1:2⋄3)', "((0, (('x', '←'), ('(', ((((1, ':'), 2), '⋄'), 3)))),)"), # naming guard expression
    ('1(z←/)¨2', "((0, ((1, (('(', (('z', '←'), '/')), '¨')), 2)),)"), # naming retains hybrid behaviour
    ('+(z←/)¨2', "((0, ((('+', ('(', (('z', '←'), '/'))), '¨'), 2)),)"), # naming retains hybrid behaviour
    ('+/¨0', "((0, ((('+', '/'), '¨'), 0)),)"), # hybrids: defining example.
    ('1/¨0', "((0, ((1, ('/', '¨')), 0)),)"), # hybrids: defining example.
    ('/./', "((1, ('/', ('.', '/'))),)"), # hybrids, jots 'n dots
    ('/∘/', "((1, ('/', ('∘', '/'))),)"), # hybrids, jots 'n dots
    ('x←↑(//)(1 2)(3 4)', "((0, (('x', '←'), ('↑', (('(', ('/', '/')), (('(', (1, 2)), ('(', (3, 4))))))),)"), # replication-reduction
    ('z←//', "((1, (('z', '←'), ('/', '/'))),)"), # ← doesn't bind with /
    ('⍺=0: ⍵+1', "((0, (((('⍺', '='), 0), ':'), (('⍵', '+'), 1))),)"), # guard.
    ('0 ⋄ 1 ⋄ 2 ⋄ 3', "((0, ((((((0, '⋄'), 1), '⋄'), 2), '⋄'), 3)),)"), # diamond segments.
    ('0:0+0 ⋄ 0:1+1 ⋄ 0:2+2 ⋄ 3', "((0, ((((((((0, ':'), ((0, '+'), 0)), '⋄'), ((0, ':'), ((1, '+'), 1))), '⋄'), ((0, ':'), ((2, '+'), 2))), '⋄'), 3)),)"), # guarded segments.
    ('(z←+ ⋄ 1+2)+3', "((0, ((('(', (((('z', '←'), '+'), '⋄'), ((1, '+'), 2))), '+'), 3)),)"), # leading non-array segment.
    (' ⋄ ⋄ ', "((15, ('⋄', '⋄')),)"), # expression lists
    (' ⋄ ⋄2', "((0, (('⋄', '⋄'), 2)),)"), # expression lists
    (' ⋄1⋄ ', "((15, (('⋄', 1), '⋄')),)"), # expression lists
    (' ⋄1⋄2', "((0, ((('⋄', 1), '⋄'), 2)),)"), # expression lists
    ('0⋄ ⋄ ', "((15, ((0, '⋄'), '⋄')),)"), # expression lists
    ('0⋄ ⋄2', "((0, (((0, '⋄'), '⋄'), 2)),)"), # expression lists
    ('0⋄1⋄ ', "((15, (((0, '⋄'), 1), '⋄')),)"), # expression lists
    ('0⋄1⋄2', "((0, ((((0, '⋄'), 1), '⋄'), 2)),)"), # expression lists
    ('0⋄0', "((0, ((0, '⋄'), 0)),)"), # expression lists
    ('+⋄0', "((0, (('+', '⋄'), 0)),)"), # expression lists
    ('/⋄0', "((0, (('/', '⋄'), 0)),)"), # expression lists
    ('¨⋄0', "((0, (('¨', '⋄'), 0)),)"), # expression lists
    ('⍣⋄0', "((0, (('⍣', '⋄'), 0)),)"), # expression lists
    ('∘⋄0', "((0, (('∘', '⋄'), 0)),)"), # expression lists
    ('.⋄0', "((0, (('.', '⋄'), 0)),)"), # expression lists
    ('[ ;;]', "((10, ('[', (';', ';'))),)"), # subscripts
    ('[ ;;3]', "((10, ('[', ((';', ';'), 3))),)"), # subscripts
    ('[ ;2;]', "((10, ('[', ((';', 2), ';'))),)"), # subscripts
    ('[ ;2;3]', "((10, ('[', (((';', 2), ';'), 3))),)"), # subscripts
    ('⍵[;;]', "((0, ('⍵', ('[', (';', ';')))),)"), # decreasing rank
    ('⍵[;]', "((0, ('⍵', ('[', ';'))),)"), # decreasing rank
    ('a[1][2][3]', "((0, ((('a', ('[', 1)), ('[', 2)), ('[', 3))),)"), # contiguous IDXs.
    ('x[2]←0', "((0, (('x', (('[', 2), '←')), 0)),)"), # indexed assignment
    ('[0]←', "((11, (('[', 0), '←')),)"), # partial indexed assignment
    ('(x y)[0]←1', "((0, ((('(', ('x', 'y')), (('[', 0), '←')), 1)),)"), # selective assignment.
    ('1/[0]⍵', "((0, ((1, ('/', ('[', 0))), '⍵')),)"), # hybrid-fn axis
    ('+/[0]⍵', "((0, ((('+', '/'), ('[', 0)), '⍵')),)"), # derived-fn axis
    ('2+/[0]⍵', "((0, ((2, (('+', '/'), ('[', 0))), '⍵')),)"), # dyadic derived-fn axis
    ('(1/)[0]⍵', "((0, ((('(', (1, '/')), ('[', 0)), '⍵')),)"), # AF with axis
    ('⍵[1]', "((0, ('⍵', ('[', 1))),)"), # array
    ('+[1]', "((1, ('+', ('[', 1))),)"), # function
    ('z[1]', "((0, ('z', ('[', 1))),)"), # name
    ('{+/[0]⍵}(2 3⍴⍳4)[;0]', "((0, (('{', ((('+', '/'), ('[', 0)), '⍵')), (('(', (((2, 3), '⍴'), ('⍳', 4))), ('[', (';', 0))))),)"), # parentheses, brackets and braces.
    ('+-×÷', "((1, ((('+', '-'), '×'), '÷')),)"), # function train.
    ('1+÷', "((1, ((1, '+'), '÷')),)"), # Agh train
    ('÷1+', "((1, ('÷', (1, '+'))),)"), # fBh train
    ('1+3×', "((1, ((1, '+'), (3, '×'))),)"), # A(fBh)
    ('1+2-3×4÷', "((1, ((((1, '+'), (2, '-')), (3, '×')), (4, '÷'))),)"), # longer (A:F)* train
    ('+/÷⍴', "((1, ((('+', '/'), '÷'), '⍴')),)"), # train for vector mean
    ('/∘⊢', "((1, ('/', ('∘', '⊢'))),)"), # fix / as replicate function
    ('+/×', "((1, (('+', '/'), '×')),)"), # 2-train
    ('+(/∘⊢)×', "((1, (('+', ('(', ('/', ('∘', '⊢')))), '×')),)"), # 3-train
    ('+/×', "((1, (('+', '/'), '×')),)"), # 2-train
    ('+(/∘⊢)×', "((1, (('+', ('(', ('/', ('∘', '⊢')))), '×')),)"), # 3-train
    ('∘', "((5, '∘'),)"), # single token.
    ('(((3)))', "((0, ('(', ('(', ('(', 3)))),)"), # deep parentheses.
    ('{⍵=1:1 ⋄ 2|⍵:∇ 1+3×⍵ ⋄ ∇ ⍵÷2}', "((1, ('{', (((((((('⍵', '='), 1), ':'), 1), '⋄'), ((((2, '|'), '⍵'), ':'), ('∇', ((1, '+'), ((3, '×'), '⍵'))))), '⋄'), ('∇', (('⍵', '÷'), 2))))),)"), # →osc← function

    #     ⍕try¨ '()' '[]' '{}'  ⍝ empty brackets
    #  ┌─┬─┐  IDX  F 
    #  │(│)│  [    { 
    #  └─┴─┘         
    
    ('()', "(-1, -1, -1, (-1, '('), ((-1, ')'), (-1, -1)))"), # empty brackets: note this is a SYNTAX ERROR
    ('[]', "((10, '['),)"), # empty brackets []
    ('{}', "((1, '{'),)"), # empty brackets {}
    ('⍵[]', "((0, ('⍵', '[')),)"), # decreasing rank
    ('⍵ x←3', "((0, ('⍵', (('x', '←'), 3))),)"), # stranding with naming.
    ('# #.⍵[1]', "((0, (('#', (('#', '.'), '⍵')), ('[', 1))),)"), # strand vs dot vs index. 
    ('⍵ x[2]←0', "((0, ('⍵', (('x', (('[', 2), '←')), 0))),)"), # stranding with indexed assignment. 
    ('#.⍵ #.(⍵+1) #.#.⍵ + 2', "((0, (((((('#', '.'), '⍵'), (('#', '.'), ('(', (('⍵', '+'), 1)))), (('#', '.'), (('#', '.'), '⍵'))), '+'), 2)),)"), # lotsa dots.
    ('x←3 4⍴⍳5 ⋄ #.⍵ ∘.+ ⍺[⍳3;] +.× ∘.{(+/⍵)÷⍴⍵}⍨ ⍺', "((0, (((('x', '←'), (((3, 4), '⍴'), ('⍳', 5))), '⋄'), (((('#', '.'), '⍵'), ('∘', ('.', '+'))), ((('⍺', ('[', (('⍳', 3), ';'))), ('+', ('.', '×'))), ((('∘', ('.', ('{', ((('(', (('+', '/'), '⍵')), '÷'), ('⍴', '⍵'))))), '⍨'), '⍺'))))),)"), # complex expression
]

@pytest.mark.parametrize("test_input,expected", test_data)
def test_parse(test_input, expected):
    assert parse_only(test_input) == expected